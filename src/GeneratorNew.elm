module GeneratorNew exposing (requestToResponse)

import Dict
import Elm.CodeGen as C
import Elm.Pretty
import Elm.Syntax.Module as Module
import Elm.Syntax.Node as Node
import Errors exposing (Res)
import Internal.Google.Protobuf exposing (FileDescriptorProto)
import Internal.Google.Protobuf.Compiler exposing (CodeGeneratorRequest, CodeGeneratorResponse, CodeGeneratorResponseFile)
import List.Extra
import MapperNew as Mapper
import Mapping.Common as Common
import Mapping.Enum as Enum
import Mapping.Import as Import
import Mapping.Message as Message
import Mapping.Name as Name
import Mapping.Struct as Struct exposing (Struct)
import Mapping.Syntax as Syntax
import Model exposing (Field(..))
import Ports
import Result.Extra
import Set
import String.Extra


requestToResponse : CodeGeneratorRequest -> CodeGeneratorResponse
requestToResponse req =
    let
        filesToResponse : List (Res CodeGeneratorResponseFile) -> CodeGeneratorResponse
        filesToResponse fileResults =
            let
                ( file, errors ) =
                    Result.Extra.partition fileResults
            in
            { error = Errors.MultipleErrors errors |> Errors.format, supportedFeatures = 3, file = file }

        files =
            convert req.fileToGenerate req.protoFile
    in
    files |> List.map (Result.map generate) |> filesToResponse


generate : C.File -> CodeGeneratorResponseFile
generate file =
    { name = (Node.value file.moduleDefinition |> Module.moduleName |> String.join "/") ++ ".elm"
    , content = "{- !!! DO NOT EDIT THIS FILE MANUALLY !!! -}\n\n" ++ Elm.Pretty.pretty 120 file
    , insertionPoint = ""
    , generatedCodeInfo = Nothing
    }


convert : List String -> List FileDescriptorProto -> List (Res C.File)
convert fileNames descriptors =
    let
        files : List ( String, Res Struct )
        files =
            descriptors
                |> List.filter (.name >> (\name -> List.member name fileNames))
                |> Mapper.mapMain

        getExposedUnionTypes struct =
            struct.enums |> List.filter .isTopLevel |> List.map .dataType

        getOneOfs struct =
            struct.messages
                |> List.concatMap .fields
                |> List.filterMap
                    (\( _, field ) ->
                        case field of
                            OneOfField dataType _ ->
                                Just dataType

                            _ ->
                                Nothing
                    )

        getExposedOtherTypes struct =
            struct.messages |> List.filter .isTopLevel |> List.map .dataType

        getAllExposedTypes struct =
            getExposedUnionTypes struct ++ getExposedOtherTypes struct
    in
    files
        |> List.map
            (\( fileName, structResult ) ->
                case structResult of
                    Ok struct ->
                        let
                            modName =
                                Name.module_ fileName

                            exposedUnionTypes =
                                struct.enums |> List.filter .isTopLevel |> List.map .dataType

                            otherExposedTypes =
                                struct.messages
                                    --|> List.filter .isTopLevel
                                    |> List.map .dataType

                            exposedFunctions =
                                (exposedUnionTypes ++ otherExposedTypes)
                                    |> List.concatMap (\t -> [ Common.decoderName t, Common.encoderName t ])

                            declarations =
                                List.concatMap Enum.toAST struct.enums
                                    ++ List.concatMap Message.toAST struct.messages
                        in
                        Ok <|
                            C.file
                                (C.normalModule modName
                                    (List.map C.openTypeExpose exposedUnionTypes
                                        ++ List.map C.openTypeExpose (getOneOfs struct)
                                        ++ List.map C.typeOrAliasExpose otherExposedTypes
                                        ++ List.map C.funExpose exposedFunctions
                                    )
                                )
                                (List.map (\importedModule -> C.importStmt importedModule Nothing Nothing) (Set.toList <| Import.extractImports declarations))
                                declarations
                                (C.emptyFileComment |> fileComment fileName |> Just)

                    Err err ->
                        Err err
            )


fileComment : String -> C.Comment C.FileComment -> C.Comment C.FileComment
fileComment fileName =
    C.markdown <| """
This file was automatically generated by
- [`protoc-gen-elm`](https://www.npmjs.com/package/protoc-gen-elm) 1.0.0-beta-2
- `protoc` 3.14.0
- the following specification file: `""" ++ fileName ++ """`

To run it, add a dependency via `elm install` on [`elm-protocol-buffers`](https://package.elm-lang.org/packages/eriktim/elm-protocol-buffers/1.1.0) version 1.1.0 or higher."""
