// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`protoc-gen-elm generates the expected code for multiple_oneof.proto 1`] = `
"{- !!! DO NOT EDIT THIS FILE MANUALLY !!! -}


module Proto.MultipleOneof exposing
    ( Oneof1Msg(..), Oneof1, Oneof2Msg(..), Oneof2
    , oneof1Decoder, oneof2Decoder
    , toOneof1Encoder, toOneof2Encoder
    )

{-| ProtoBuf module: \`Proto.MultipleOneof\`

This module was generated automatically using

  - [\`protoc-gen-elm\`](https://www.npmjs.com/package/protoc-gen-elm) 1.0.0
  - \`protoc\` 3.14.0
  - the following specification file: \`multiple_oneof.proto\`

To run it use [\`elm-protocol-buffers\`](https://package.elm-lang.org/packages/eriktim/elm-protocol-buffers/1.1.0) version 1.1.0 or higher.


# Model

@docs Oneof1Msg, Oneof1, Oneof2Msg, Oneof2


# Decoder

@docs oneof1Decoder, oneof2Decoder


# Encoder

@docs toOneof1Encoder, toOneof2Encoder

-}

import Protobuf.Decode as Decode
import Protobuf.Encode as Encode



-- MODEL


{-| Oneof1Msg
-}
type Oneof1Msg
    = MsgOptionA String
    | MsgOptionB String


{-| \`Oneof1\` message
-}
type alias Oneof1 =
    { msg : Maybe Oneof1Msg
    }


{-| Oneof2Msg
-}
type Oneof2Msg
    = MsgOptionC String
    | MsgOptionD String


{-| \`Oneof2\` message
-}
type alias Oneof2 =
    { msg : Maybe Oneof2Msg
    }



-- DECODER


{-| \`Oneof1\` decoder
-}
oneof1Decoder : Decode.Decoder Oneof1
oneof1Decoder =
    Decode.message (Oneof1 Nothing)
        [ Decode.oneOf
            [ ( 1, Decode.map MsgOptionA Decode.string )
            , ( 2, Decode.map MsgOptionB Decode.string )
            ]
            setMsg
        ]


{-| \`Oneof2\` decoder
-}
oneof2Decoder : Decode.Decoder Oneof2
oneof2Decoder =
    Decode.message (Oneof2 Nothing)
        [ Decode.oneOf
            [ ( 1, Decode.map MsgOptionC Decode.string )
            , ( 2, Decode.map MsgOptionD Decode.string )
            ]
            setMsg
        ]



-- ENCODER


toOneof1MsgEncoder : Oneof1Msg -> ( Int, Encode.Encoder )
toOneof1MsgEncoder model =
    case model of
        MsgOptionA value ->
            ( 1, Encode.string value )

        MsgOptionB value ->
            ( 2, Encode.string value )


{-| \`Oneof1\` encoder
-}
toOneof1Encoder : Oneof1 -> Encode.Encoder
toOneof1Encoder model =
    Encode.message
        [ Maybe.withDefault ( 0, Encode.none ) <| Maybe.map toOneof1MsgEncoder model.msg
        ]


toOneof2MsgEncoder : Oneof2Msg -> ( Int, Encode.Encoder )
toOneof2MsgEncoder model =
    case model of
        MsgOptionC value ->
            ( 1, Encode.string value )

        MsgOptionD value ->
            ( 2, Encode.string value )


{-| \`Oneof2\` encoder
-}
toOneof2Encoder : Oneof2 -> Encode.Encoder
toOneof2Encoder model =
    Encode.message
        [ Maybe.withDefault ( 0, Encode.none ) <| Maybe.map toOneof2MsgEncoder model.msg
        ]



-- SETTERS


setMsg : a -> { b | msg : a } -> { b | msg : a }
setMsg value model =
    { model | msg = value }
"
`;
